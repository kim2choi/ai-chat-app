import os
import requests
from openai import OpenAI
from dotenv import load_dotenv
from datetime import datetime
import json
from typing import List, Dict, Set
import time

load_dotenv()

fmp_key = os.getenv("FMP_API_KEY")
client = OpenAI(api_key=os.getenv("OPENAI_API_KEY"))

class ProfessionalStockScreener:
    """
    Ïã§Ï†Ñ Í∏∞Í¥ÄÌà¨ÏûêÏûêÍ∏â Ï¢ÖÎ™© Î∞úÍµ¥ ÏãúÏä§ÌÖú
    - Universe Í∏∞Î∞ò Ï≤¥Í≥ÑÏ†Å Ïä§ÌÅ¨Î¶¨Îãù
    - 4Í∞ÄÏßÄ Í≤ÄÏ¶ùÎêú Ìà¨Ïûê Ï†ÑÎûµ
    - CIOÍ∏â ÏµúÏ¢Ö ÌÜµÌï© Î∂ÑÏÑù
    """
    
    def __init__(self):
        # Universe Ï∫êÏãú
        self._universe_cache = {}
        
        # Ï†ÑÎûµÎ≥Ñ Universe Îß§Ìïë
        self.strategy_config = {
            'hidden_gems': {
                'name': 'Hidden Gems (Ïà®ÏùÄ Î≥¥ÏÑù)',
                'universes': ['small_cap', 'mid_cap'],
                'description': 'Ï†ÄÌèâÍ∞Ä Í≥†ÏÑ±Ïû• Ï§ëÏÜåÌòïÏ£º'
            },
            'deep_value': {
                'name': 'Deep Value (Í∞ÄÏπòÏ£º)',
                'universes': ['large_cap', 'mid_cap', 'small_cap'],
                'description': 'Í∑πÎã®Ï†Å Ï†ÄÌèâÍ∞Ä Ï†Ñ ÏãúÏ¥ù'
            },
            'quality_growth': {
                'name': 'Quality Growth (ÌÄÑÎ¶¨Ìã∞ ÏÑ±Ïû•)',
                'universes': ['large_cap', 'mid_cap'],
                'description': 'ÏïàÏ†ïÏ†Å Í≥†ÏàòÏùµ ÎåÄÏ§ëÌòïÏ£º'
            },
            'momentum': {
                'name': 'Momentum (Î™®Î©òÌÖÄ)',
                'universes': ['large_cap', 'mid_cap'],
                'description': 'Í∞ïÎ†•Ìïú ÏÉÅÏäπÏÑ∏ Ï†Ñ ÏãúÏ¥ù'
            }
        }
    
    # ===== Universe Í¥ÄÎ¶¨ =====
    
    def get_universe(self, universe_type: str) -> List[str]:
        """Universe Í∞ÄÏ†∏Ïò§Í∏∞ (Ï∫êÏãú ÌôúÏö©)"""
        
        if universe_type in self._universe_cache:
            return self._universe_cache[universe_type]
        
        print(f"   üì• {universe_type} Universe Î°úÎî©...")
        
        if universe_type == 'large_cap':
            symbols = self._get_large_cap()
        elif universe_type == 'mid_cap':
            symbols = self._get_mid_cap()
        elif universe_type == 'small_cap':
            symbols = self._get_small_cap()
        else:
            symbols = []
        
        self._universe_cache[universe_type] = symbols
        print(f"   ‚úÖ {len(symbols)} Ï¢ÖÎ™© Î°úÎìúÎê®")
        
        return symbols
    
    def _get_large_cap(self) -> List[str]:
        """ÎåÄÌòïÏ£º (ÏãúÏ¥ù 100Ïñµ+)"""
        
        # S&P 500 Í∏∞Î∞ò
        url = f"https://financialmodelingprep.com/api/v3/sp500_constituent?apikey={fmp_key}"
        response = requests.get(url)
        
        if response.status_code == 200:
            data = response.json()
            return [stock['symbol'] for stock in data]
        
        # ÎåÄÏïà: ÏßÅÏ†ë Ïä§ÌÅ¨Î¶¨Îãù
        return self._screener_query(
            market_cap_more=100000000000,
            limit=200
        )
    
    def _get_mid_cap(self) -> List[str]:
        """Ï§ëÌòïÏ£º (ÏãúÏ¥ù 20Ïñµ~100Ïñµ)"""
        return self._screener_query(
            market_cap_more=2000000000,
            market_cap_lower=100000000000,
            limit=300
        )
    
    def _get_small_cap(self) -> List[str]:
        """ÏÜåÌòïÏ£º (ÏãúÏ¥ù 3Ïñµ~20Ïñµ)"""
        return self._screener_query(
            market_cap_more=300000000,
            market_cap_lower=2000000000,
            limit=300
        )
    
    def _screener_query(self, market_cap_more=None, market_cap_lower=None, limit=100) -> List[str]:
        """FMP Ïä§ÌÅ¨Î¶¨ÎÑà ÏøºÎ¶¨"""
        
        url = f"https://financialmodelingprep.com/api/v3/stock-screener"
        params = {
            'volumeMoreThan': 100000,
            'limit': limit,
            'apikey': fmp_key
        }
        
        if market_cap_more:
            params['marketCapMoreThan'] = market_cap_more
        if market_cap_lower:
            params['marketCapLowerThan'] = market_cap_lower
        
        try:
            response = requests.get(url, params=params)
            data = response.json()
            return [stock['symbol'] for stock in data]
        except:
            return []
    
    # ===== Î©îÏù∏ Ïä§Ï∫î Î°úÏßÅ =====
    
    def scan_all_strategies(self, stocks_per_strategy=3):
        """Ï†ÑÏ≤¥ Ï†ÑÎûµ Ïä§Ï∫î"""
        
        print("=" * 80)
        print("üè¶ PROFESSIONAL STOCK SCREENER - Institutional Grade")
        print("=" * 80)
        print(f"‚è∞ ÏãúÏûë ÏãúÍ∞Å: {datetime.now().strftime('%Y-%m-%d %H:%M:%S')}")
        print("=" * 80)
        
        all_results = {}
        
        for strategy_key, config in self.strategy_config.items():
            print(f"\n{'='*80}")
            print(f"üìä Ï†ÑÎûµ: {config['name']}")
            print(f"üìù ÏÑ§Î™Ö: {config['description']}")
            print(f"üéØ Universe: {', '.join(config['universes'])}")
            print(f"{'='*80}")
            
            # Universe ÏàòÏßë
            candidates = self._collect_candidates(config['universes'])
            print(f"\nÏ¥ù ÌõÑÎ≥¥: {len(candidates)} Ï¢ÖÎ™©")
            
            # Ï†ÑÎûµ Ïã§Ìñâ
            picks = self._execute_strategy(strategy_key, candidates, stocks_per_strategy)
            all_results[strategy_key] = {
                'config': config,
                'picks': picks
            }
            
            print(f"‚úÖ {len(picks)} Ï¢ÖÎ™© ÏÑ†Ï†ï ÏôÑÎ£å\n")
            time.sleep(1)  # API rate limit
        
        # AI ÏµúÏ¢Ö Î∂ÑÏÑù
        print("\n" + "="*80)
        print("ü§ñ CIO ÏµúÏ¢Ö ÌÜµÌï© Î∂ÑÏÑù Ï§ë...")
        print("="*80)
        
        final_report = self._ai_final_analysis(all_results)
        
        return final_report
    
    def _collect_candidates(self, universes: List[str]) -> List[str]:
        """UniverseÏóêÏÑú ÌõÑÎ≥¥ ÏàòÏßë"""
        
        all_symbols = set()
        
        for universe in universes:
            symbols = self.get_universe(universe)
            all_symbols.update(symbols)
        
        return list(all_symbols)
    
    def _execute_strategy(self, strategy_key: str, candidates: List[str], top_n: int) -> List[Dict]:
        """Ï†ÑÎûµ Ïã§Ìñâ"""
        
        if strategy_key == 'hidden_gems':
            return self._find_hidden_gems(candidates, top_n)
        elif strategy_key == 'deep_value':
            return self._find_deep_value(candidates, top_n)
        elif strategy_key == 'quality_growth':
            return self._find_quality_growth(candidates, top_n)
        elif strategy_key == 'momentum':
            return self._find_momentum(candidates, top_n)
        
        return []
    
    # ===== Ï†ÑÎûµ 1: Hidden Gems =====
    
    def _find_hidden_gems(self, candidates: List[str], top_n: int) -> List[Dict]:
        """Ïà®ÏùÄ Î≥¥ÏÑù Î∞úÍµ¥"""
        
        gems = []
        
        print("   Î∂ÑÏÑù Ï§ë: ", end="", flush=True)
        for i, symbol in enumerate(candidates[:100]):  # Ï≤òÏùå 100Í∞úÎßå
            if i % 10 == 0:
                print(".", end="", flush=True)
            
            try:
                analysis = self._analyze_hidden_gem(symbol)
                if analysis and analysis['is_gem']:
                    gems.append(analysis)
            except:
                continue
            
            time.sleep(0.1)  # Rate limit
        
        print(" ÏôÑÎ£å!")
        
        gems.sort(key=lambda x: x['score'], reverse=True)
        return gems[:top_n]
    
    def _analyze_hidden_gem(self, symbol: str) -> Dict:
        """Hidden Gem Î∂ÑÏÑù"""
        
        quote = self._get_quote(symbol)
        if not quote:
            return None
        
        ratios = self._get_ratios(symbol)
        growth = self._get_growth(symbol)
        
        # Îç∞Ïù¥ÌÑ∞ Ï∂îÏ∂ú
        price = quote.get('price', 0)
        market_cap = quote.get('marketCap', 0)
        pe = quote.get('pe', 999)
        
        peg = ratios.get('pegRatio', 999) if ratios else 999
        revenue_growth = growth.get('revenueGrowth', 0) if growth else 0
        
        # Ï†êÏàò Í≥ÑÏÇ∞
        score = 0
        reasons = []
        
        # 1. Í≥†ÏÑ±Ïû• (40Ï†ê)
        if revenue_growth > 30:
            score += 40
            reasons.append(f"Îß§Ï∂ú ÏÑ±Ïû• {revenue_growth:.1f}%")
        elif revenue_growth > 20:
            score += 30
            reasons.append(f"Îß§Ï∂ú ÏÑ±Ïû• {revenue_growth:.1f}%")
        elif revenue_growth > 10:
            score += 20
        
        # 2. Ï†ÄPEG (30Ï†ê)
        if 0 < peg < 1:
            score += 30
            reasons.append(f"PEG {peg:.2f} (Ï†ÄÌèâÍ∞Ä)")
        elif peg < 1.5:
            score += 20
            reasons.append(f"PEG {peg:.2f}")
        elif peg < 2:
            score += 10
        
        # 3. Ï§ëÏÜåÌòïÏ£º (20Ï†ê)
        if market_cap < 5e9:
            score += 20
            reasons.append("ÏÜåÌòïÏ£º")
        elif market_cap < 20e9:
            score += 15
            reasons.append("Ï§ëÏÜåÌòïÏ£º")
        elif market_cap < 50e9:
            score += 10
        
        # 4. Ï†ÅÏ†ï PE (10Ï†ê)
        if 10 < pe < 25:
            score += 10
            reasons.append(f"PE {pe:.1f}")
        elif 5 < pe < 35:
            score += 5
        
        is_gem = score >= 60
        
        return {
            'symbol': symbol,
            'name': quote.get('name', 'N/A'),
            'price': price,
            'market_cap': market_cap,
            'pe': pe,
            'peg': peg,
            'revenue_growth': revenue_growth,
            'score': score,
            'is_gem': is_gem,
            'reasons': reasons,
            'category': 'Hidden Gem'
        }
    
    # ===== Ï†ÑÎûµ 2: Deep Value =====
    
    def _find_deep_value(self, candidates: List[str], top_n: int) -> List[Dict]:
        """Í∞ÄÏπòÏ£º Î∞úÍµ¥"""
        
        value_stocks = []
        
        print("   Î∂ÑÏÑù Ï§ë: ", end="", flush=True)
        for i, symbol in enumerate(candidates[:100]):
            if i % 10 == 0:
                print(".", end="", flush=True)
            
            try:
                analysis = self._analyze_value(symbol)
                if analysis and analysis['is_value']:
                    value_stocks.append(analysis)
            except:
                continue
            
            time.sleep(0.1)
        
        print(" ÏôÑÎ£å!")
        
        value_stocks.sort(key=lambda x: x['score'], reverse=True)
        return value_stocks[:top_n]
    
    def _analyze_value(self, symbol: str) -> Dict:
        """Í∞ÄÏπòÏ£º Î∂ÑÏÑù (Graham Î∞©Ïãù)"""
        
        quote = self._get_quote(symbol)
        if not quote:
            return None
        
        ratios = self._get_ratios(symbol)
        
        pe = quote.get('pe', 999)
        pb = ratios.get('priceToBookRatio', 999) if ratios else 999
        roe = ratios.get('roe', 0) if ratios else 0
        div_yield = ratios.get('dividendYield', 0) if ratios else 0
        
        score = 0
        reasons = []
        
        # 1. P/B (30Ï†ê)
        if pb < 1:
            score += 30
            reasons.append(f"P/B {pb:.2f} (Ïû•Î∂ÄÍ∞Ä Ïù¥Ìïò)")
        elif pb < 1.5:
            score += 20
            reasons.append(f"P/B {pb:.2f}")
        elif pb < 2:
            score += 10
        
        # 2. P/E (30Ï†ê)
        if 5 < pe < 12:
            score += 30
            reasons.append(f"P/E {pe:.1f} (Ï†ÄÌèâÍ∞Ä)")
        elif pe < 18:
            score += 20
            reasons.append(f"P/E {pe:.1f}")
        elif pe < 25:
            score += 10
        
        # 3. ROE (20Ï†ê)
        if roe > 15:
            score += 20
            reasons.append(f"ROE {roe:.1f}%")
        elif roe > 10:
            score += 15
        elif roe > 5:
            score += 10
        
        # 4. Î∞∞Îãπ (20Ï†ê)
        if div_yield > 3:
            score += 20
            reasons.append(f"Î∞∞Îãπ {div_yield:.1f}%")
        elif div_yield > 2:
            score += 15
        elif div_yield > 1:
            score += 10
        
        is_value = score >= 60
        
        return {
            'symbol': symbol,
            'name': quote.get('name', 'N/A'),
            'price': quote.get('price', 0),
            'pe': pe,
            'pb': pb,
            'roe': roe,
            'dividend': div_yield,
            'score': score,
            'is_value': is_value,
            'reasons': reasons,
            'category': 'Deep Value'
        }
    
    # ===== Ï†ÑÎûµ 3: Quality Growth =====
    
    def _find_quality_growth(self, candidates: List[str], top_n: int) -> List[Dict]:
        """ÌÄÑÎ¶¨Ìã∞ ÏÑ±Ïû•Ï£º Î∞úÍµ¥"""
        
        quality_stocks = []
        
        print("   Î∂ÑÏÑù Ï§ë: ", end="", flush=True)
        for i, symbol in enumerate(candidates[:100]):
            if i % 10 == 0:
                print(".", end="", flush=True)
            
            try:
                analysis = self._analyze_quality(symbol)
                if analysis and analysis['is_quality']:
                    quality_stocks.append(analysis)
            except:
                continue
            
            time.sleep(0.1)
        
        print(" ÏôÑÎ£å!")
        
        quality_stocks.sort(key=lambda x: x['score'], reverse=True)
        return quality_stocks[:top_n]
    
    def _analyze_quality(self, symbol: str) -> Dict:
        """ÌÄÑÎ¶¨Ìã∞ Î∂ÑÏÑù (Lynch/Buffett Î∞©Ïãù)"""
        
        quote = self._get_quote(symbol)
        if not quote:
            return None
        
        ratios = self._get_ratios(symbol)
        growth = self._get_growth(symbol)
        
        roe = ratios.get('roe', 0) if ratios else 0
        roic = ratios.get('roic', 0) if ratios else 0
        revenue_growth = growth.get('revenueGrowth', 0) if growth else 0
        
        score = 0
        reasons = []
        
        # 1. ROE (35Ï†ê)
        if roe > 25:
            score += 35
            reasons.append(f"ROE {roe:.1f}% (ÌÉÅÏõî)")
        elif roe > 20:
            score += 25
            reasons.append(f"ROE {roe:.1f}%")
        elif roe > 15:
            score += 15
        
        # 2. ÏùºÍ¥ÄÎêú ÏÑ±Ïû• (35Ï†ê)
        if revenue_growth > 20:
            score += 35
            reasons.append(f"Îß§Ï∂ú ÏÑ±Ïû• {revenue_growth:.1f}%")
        elif revenue_growth > 15:
            score += 25
        elif revenue_growth > 10:
            score += 15
        
        # 3. ROIC (30Ï†ê)
        if roic > 20:
            score += 30
            reasons.append(f"ROIC {roic:.1f}%")
        elif roic > 15:
            score += 20
        elif roic > 10:
            score += 10
        
        is_quality = score >= 60
        
        return {
            'symbol': symbol,
            'name': quote.get('name', 'N/A'),
            'price': quote.get('price', 0),
            'roe': roe,
            'roic': roic,
            'revenue_growth': revenue_growth,
            'score': score,
            'is_quality': is_quality,
            'reasons': reasons,
            'category': 'Quality Growth'
        }
    
    # ===== Ï†ÑÎûµ 4: Momentum =====
    
    def _find_momentum(self, candidates: List[str], top_n: int) -> List[Dict]:
        """Î™®Î©òÌÖÄÏ£º Î∞úÍµ¥"""
        
        momentum_stocks = []
        
        print("   Î∂ÑÏÑù Ï§ë: ", end="", flush=True)
        for i, symbol in enumerate(candidates[:100]):
            if i % 10 == 0:
                print(".", end="", flush=True)
            
            try:
                analysis = self._analyze_momentum(symbol)
                if analysis and analysis['has_momentum']:
                    momentum_stocks.append(analysis)
            except:
                continue
            
            time.sleep(0.1)
        
        print(" ÏôÑÎ£å!")
        
        momentum_stocks.sort(key=lambda x: x['score'], reverse=True)
        return momentum_stocks[:top_n]
    
    def _analyze_momentum(self, symbol: str) -> Dict:
        """Î™®Î©òÌÖÄ Î∂ÑÏÑù (O'Neil Î∞©Ïãù)"""
        
        quote = self._get_quote(symbol)
        if not quote:
            return None
        
        price = quote.get('price', 0)
        change = quote.get('changesPercentage', 0)
        year_high = quote.get('yearHigh', 0)
        year_low = quote.get('yearLow', 0)
        
        # 52Ï£º Í≥†Í∞Ä Í∑ºÏ†ëÎèÑ
        high_proximity = (price / year_high * 100) if year_high > 0 else 0
        
        score = 0
        reasons = []
        
        # 1. ÏµúÍ∑º ÏÉÅÏäπÎ•† (40Ï†ê)
        if change > 10:
            score += 40
            reasons.append(f"ÏÉÅÏäπ {change:.1f}%")
        elif change > 5:
            score += 30
        elif change > 2:
            score += 20
        
        # 2. 52Ï£º Í≥†Í∞Ä Í∑ºÏ†ë (40Ï†ê)
        if high_proximity > 95:
            score += 40
            reasons.append("52Ï£º Ïã†Í≥†Í∞Ä Í∑ºÏ†ë")
        elif high_proximity > 90:
            score += 30
        elif high_proximity > 85:
            score += 20
        
        # 3. Ïó∞Í∞Ñ ÏÉÅÏäπÌè≠ (20Ï†ê)
        if year_high > 0 and year_low > 0:
            year_range = (year_high - year_low) / year_low * 100
            if year_range > 100:
                score += 20
                reasons.append(f"Ïó∞Ï§ë {year_range:.0f}% ÏÉÅÏäπ")
            elif year_range > 50:
                score += 15
            elif year_range > 30:
                score += 10
        
        has_momentum = score >= 60
        
        return {
            'symbol': symbol,
            'name': quote.get('name', 'N/A'),
            'price': price,
            'change': change,
            'high_proximity': high_proximity,
            'score': score,
            'has_momentum': has_momentum,
            'reasons': reasons,
            'category': 'Momentum'
        }
    
    # ===== Îç∞Ïù¥ÌÑ∞ Ìó¨Ìçº Ìï®Ïàò =====
    
    def _get_quote(self, symbol: str) -> Dict:
        """ÏãúÏÑ∏ Ï†ïÎ≥¥"""
        try:
            url = f"https://financialmodelingprep.com/api/v3/quote/{symbol}?apikey={fmp_key}"
            response = requests.get(url, timeout=5)
            data = response.json()
            return data[0] if data else None
        except:
            return None
    
    def _get_ratios(self, symbol: str) -> Dict:
        """Ïû¨Î¨¥ ÎπÑÏú®"""
        try:
            url = f"https://financialmodelingprep.com/api/v3/key-metrics/{symbol}?limit=1&apikey={fmp_key}"
            response = requests.get(url, timeout=5)
            data = response.json()
            return data[0] if data else None
        except:
            return None
    
    def _get_growth(self, symbol: str) -> Dict:
        """ÏÑ±Ïû•Î•†"""
        try:
            url = f"https://financialmodelingprep.com/api/v3/financial-growth/{symbol}?limit=1&apikey={fmp_key}"
            response = requests.get(url, timeout=5)
            data = response.json()
            
            if data:
                return {
                    'revenueGrowth': data[0].get('revenueGrowth', 0) * 100
                }
            return None
        except:
            return None
    
    # ===== AI ÏµúÏ¢Ö Î∂ÑÏÑù =====
    
    def _ai_final_analysis(self, all_results: Dict) -> Dict:
        """CIOÍ∏â ÌÜµÌï© Î∂ÑÏÑù"""
        
        # Í≤∞Í≥º ÏöîÏïΩ
        summary = "=== Ï†ÑÎ¨∏Í∞ÄÍ∏â Î©ÄÌã∞Ï†ÑÎûµ Ïä§ÌÅ¨Î¶¨Îãù Í≤∞Í≥º ===\n\n"
        
        for strategy_key, data in all_results.items():
            config = data['config']
            picks = data['picks']
            
            summary += f"\n## {config['name']}\n"
            summary += f"Universe: {', '.join(config['universes'])}\n"
            summary += f"Î∞úÍµ¥: {len(picks)} Ï¢ÖÎ™©\n\n"
            
            for i, stock in enumerate(picks, 1):
                summary += f"{i}. {stock['symbol']} - {stock['name']}\n"
                summary += f"   Í∞ÄÍ≤©: ${stock['price']:.2f}\n"
                summary += f"   Ï†êÏàò: {stock['score']}/100\n"
                summary += f"   ÌäπÏßï: {', '.join(stock.get('reasons', []))}\n"
        
        # GPT-4o CIO Î∂ÑÏÑù
        prompt = f"""
ÎãπÏã†ÏùÄ 30ÎÖÑ Í≤ΩÎ†•Ïùò CIO(ÏµúÍ≥†Ìà¨ÏûêÏ±ÖÏûÑÏûê)ÏûÖÎãàÎã§.

4Í∞ÄÏßÄ Ï†ÑÎ¨∏ Ï†ÑÎûµÏúºÎ°ú Î∞úÍµ¥Îêú Ï¢ÖÎ™©Îì§ÏùÑ Í≤ÄÌÜ†ÌïòÍ≥† Ïã§Ìñâ Í∞ÄÎä•Ìïú Ìà¨Ïûê Í≥ÑÌöçÏùÑ ÏàòÎ¶ΩÌïòÏÑ∏Ïöî:

{summary}

**CIO ÏµúÏ¢Ö Î¶¨Ìè¨Ìä∏:**

1. Executive Summary (ÌïµÏã¨ ÏöîÏïΩ)
   - ÏãúÏû• ÌôòÍ≤Ω Ìïú Ï§Ñ
   - ÌïµÏã¨ Í∏∞Ìöå Ìïú Ï§Ñ

2. Ï†ÑÎûµÎ≥Ñ ÌèâÍ∞Ä
   - Í∞Å Ï†ÑÎûµÏùò Í∞ïÏ†ê
   - ÌòÑÏû¨ ÏãúÏû•ÏóêÏÑúÏùò Ï†ÅÌï©ÏÑ±

3. Top 5 Conviction Picks
   - Ï†Ñ Ï†ÑÎûµ ÌÜµÌãÄÏñ¥ ÏµúÍ≥† 5Í∞ú
   - Í∞ÅÍ∞Å: Ï¢ÖÎ™©Î™Ö, Ïπ¥ÌÖåÍ≥†Î¶¨, ÏÑ†Ï†ï Ïù¥Ïú†, Î™©Ìëú ÏàòÏùµÎ•†

4. Ìè¨Ìä∏Ìè¥Î¶¨Ïò§ Íµ¨ÏÑ± Ï†úÏïà
   - Í∞Å Ï†ÑÎûµ ÎπÑÏ§ë (%)
   - Î¶¨Ïä§ÌÅ¨ Í¥ÄÎ¶¨ Î∞©Ïïà

5. Ïã§Ìñâ Í≥ÑÌöç
   - 1Ï£ºÏ∞® Ïï°ÏÖò
   - Î™®ÎãàÌÑ∞ÎßÅ Ìè¨Ïù∏Ìä∏

Ï†ÑÎ¨∏Ï†ÅÏù¥Í≥† Ïã§Ìñâ Í∞ÄÎä•ÌïòÍ≤å ÏûëÏÑ±ÌïòÏÑ∏Ïöî.
"""
        
        response = client.chat.completions.create(
            model="gpt-4o",
            messages=[{"role": "user", "content": prompt}],
            max_tokens=1500
        )
        
        return {
            'timestamp': datetime.now().strftime("%Y-%m-%d %H:%M:%S"),
            'strategies': all_results,
            'cio_report': response.choices[0].message.content
        }


# ===== Ïã§Ìñâ =====
if __name__ == "__main__":
    screener = ProfessionalStockScreener()
    
    # Ï†ÑÏ≤¥ Ïä§Ï∫î
    report = screener.scan_all_strategies(stocks_per_strategy=3)
    
    # Í≤∞Í≥º Ï∂úÎ†•
    print("\n" + "="*80)
    print("üìä CIO ÏµúÏ¢Ö Ìà¨Ïûê Î¶¨Ìè¨Ìä∏")
    print("="*80)
    print(report['cio_report'])
    
    # Ï†ÄÏû•
    filename = f"stock_discovery_{datetime.now().strftime('%Y%m%d_%H%M')}.json"
    with open(filename, 'w', encoding='utf-8') as f:
        json.dump(report, f, indent=2, ensure_ascii=False)
    
    print(f"\nüíæ Î¶¨Ìè¨Ìä∏ Ï†ÄÏû•: {filename}")
    print(f"‚è∞ ÏôÑÎ£å ÏãúÍ∞Å: {datetime.now().strftime('%Y-%m-%d %H:%M:%S')}")